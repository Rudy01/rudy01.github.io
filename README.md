# C1_SAIC_InternProg
This is the project space for SAIC Interns

**This document will detail the implementation and usage for the intern dashboard project. This project uses Terraform to automatically provision CloudWatch alarms and dashboards for services in two different ways: either at the same time as AWS resources are being provisioned, or after the serviceâ€™s resources have already been provisioned.**

# Provisioning Templates
`dash_and_infra`: Provisions infrastructure and a dashboard simultaneously. Useful for standing up services **and** continuous monitoring (managing infrastructure and dashboards with the **same** state).
- Inputs
  - `service_name`: The name of the common service you're provisioning for
  - `aws_region`: The AWS region to provision to
  - `beanstalk`: A list of Elastic Beanstalk definitions
    - `bean_app_name`: The name of the Beanstalk application
    - `bean_env_names`: The list of the names of the Beanstalk environments
    - `solution_stack_name`: The name of the Beanstalk solution stack
    - `subnets`: The list of the subnets and their attributes
      - `name`: The name of the subnet
      - `id`: The ID of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this `name` and `id` should be `null`
  - `ec2`: List of EC2 instance attributes
    - `name`: The name of the EC2 instance
    - `subnet`:  An object that defines a subnet
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this `name` and `id` should be `null`
  - `ecs_cluster_names`: A list of cluster definitions for this service
  - `ecs_task_definitions`: A list of task definitions for ECS-EC2
    - `container_definitions`: An object containing definitions for each of the containers involved in a task
      - `name`: The name of a container
      - `image`: The image used to start a container
      - `cpu`: The amount of vCPU to reserve
      - `memory`: The amount of memory to reserve
      - `essential`: Option to decide if the task stops upon container failure
      - `port_mappings`: Allows containers to access ports on the host container instance to send or receive traffic
        - `containerPort`: The port number on the container that's bound to the user-specified or automatically assigned host port
        - `hostPort`: The port number on the container instance to reserve for your container
    - `task_name`: The name of the ECS task being generated
    - `availability_zone`: The availability zone of the service
    - `services`: The name of the ECS services to provision for a given task definition
      - `name`: The name of ECS service
      - `desired_count`: The number services you need for ECS
    - `cluster_name`: The name of the cluster to which this ECS task description is being assigned
  - `eks_clusters`: A list of the EKS cluster definitions for this service
    - `name`: The name of the EKS cluster
    - `subnets`: A list of subnets and their attributes
      - `name`: The name of the subnet
      - `id`: The ID of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `user_names`: The list of the user names
  - `fargate_profiles`: A list of EKS Fargate profile definitions
    - `name`: The name of the Fargate profile
    - `subnets`: A list of subnets and their attributes
      - `name`: The name of the subnet
      - `id`: The ID of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `cluster_name`: The name of the cluster to which this EKS task description is being assigned
  - `fargate_task_definitions`: A list of task definitions for ECS-Fargate
    - `containter_definitions`: An object containing definitions for each of the containers involved in a task
      - `name`: The name of a container
      - `image`: The image used to start a container
      - `cpu`: The amount of vCPU to reserve
      - `memory`: The amount of memory to reserve
      - `essential`: Option to decide if the task stops upon container failure
      - `port_mappings`: Allows containers to access ports on the host container instance to send or receive traffic
        - `containerPort`: The port number on the container that's bound to the user-specified or automatically assigned host port
        - `hostPort`: The port number on the container instance to reserve for your container
    - `task_name`: The name of the Fargate task being generated
    - `services`: The name of the Fargate services to provision for a given task definition
      - `name`: The name of Fargate service
      - `desired_count`: The number services you need for Fargate
      - `subnets`: A list of subnets and their attributes
        - `name`: The name of the subnet
        - `id`: The ID of the subnet
        - `type`: Indicates who created the subnet
          - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
          - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
          - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `cluster_name`: The name of the cluster to which this Fargate task description is being assigned
  - `height`: The height of each widgets
  - `lambdas`: List of all lambda functions to use/create. 
    - `file`: The file name of the Lambda function (add .zip file to the service directory)
    - `security_group_indices`: Indices of the security_groups variable corresponding to the security groups associated with the lambda function.
    - `subnets`: The subnets this lambda function is in
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
  - `list_of_emails`: A list of emails that you would like to receive updates for the dashboard alarms
    - **Must include only SAIC emails**
  - `nat_gatways`: A list of all NAT gateways and their attributes
    - `name`: The name of the NAT gateway
    - `connectivity_type`: Whether the NAT gateway is public (connects to Internet) or private (connects to other VPCs)
    - `subnets`: The subnets this route table is in
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `private_ip`: The private IP address for the NAT gateway
  - `network_acls`: A list of all network ACLs and their attributes
    - `network_acl_name`: The name of the network ACL
    - `rules`: Describes the rules for the NACL
      - `from_port`: The source port of traffic
      - `to_port`: The destination port of traffic
      - `protocol`: The protocol (TCP/UDP) used
      - `rule_action`: Whether to allow or deny traffic
      - `rule_number`: The numerical order of the rule. Rules are executed in numerical order
      - `egress`: Does this rule applies to outgoing traffic too, or just incoming traffic (true/false)?
    - `subnets`: The subnets this route table is in
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `cider_block`: The CIDR block associated with the Network ACL
  - `node_groups`: A list of EKS node group definitions
    - `name`: The name of the node group
    - `cluster_name`: The name of the cluster
    - `subnets`: A list of subnets and their attributes
      - `name`: The name of the subnet
      - `id`: The ID of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the name should be null and you should provide the subnet id
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
    - `instance_types`: A list of the EC2 instance types associated with the node group
    - `desired_size`: Desired number of worker nodes
    - `max_size`: Maximum number of worker nodes
    - `min_size`: Minimum number of worker nodes
    - `max_unavailable`: Desired max number of unavailable worker nodes during a node group update
  - `num_widgets`: The number of widgets in a dashboard row
  - `route_tables`: A list of route tables and their routes
    - `name`: The name of the route table being provisioned
    - `routes`: Provision routes for a route table within a VPC
      - `destination_cidr_block`: The IPv4 CIDR range specified in a route in the table
      - `gateway_name`: The name of a gateway
      - `gateway_type`: The type of gateway
    - `subnets`: The subnets this route table is in
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this both `name` and `id` should be `null`
  - `security_groups`: A list of all security groups and their attributes
    - `security_group_name`: The name of the security group
    - `description`: A description of what the security group does
    - `rules`: Describes the rules for the security group
      - `from_port`: The source port of traffic
      - `to_port`: The destination port of traffic
      - `protocol`: The protocol (TCP/UDP) used
      - `type`: Whether traffic is coming in (`ingress`) or going out (`egress`)
    - `vpc`: The VPC for the subnet
      - `name`: The name of the VPC
      - `id`: The id of the VPC
      - `type`: Indicates who created the subnet
        - `user`: A user created the VPC using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the VPC using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for VPC that AWS created. If you want this both `name` and `id` should be `null`
    - `cidr_blocks`: The CIDR blocks associated with the security group
  - `servers`: List of EC2 server instance attributes
    - `name`: The name of the server instance
    - `security_group_index`: The index of security groups that will apply to this server. Taken from the indices of the `security_groups` object defined below
    - `subnet`: An object that defines a subnet
      - `name`: The name of the subnet
      - `id`: The id of the subnet
      - `type`: Indicates who created the subnet
        - `user`: A user created the subnet using ClickOps. If you want this the `id` should be `null` and **you should provide the subnet name**
        - `created`: We make the subnet using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default for subnet that AWS created. If you want this `name` and `id` should be `null`
    - `private_ips`: The IP address (or addresses) associated with the server.
    - `server_ami`: The AMI of the server (Describes what OS the server will operate on)
    - `container_instance`: If `true` it allows you to create an ECS container instance for the subnet
    - `cluster_name`: The name of the cluster to which this ECS instance is being assigned
  - `subnets`: An object containing the subnet names and route tables associated with those subnets
    - `cidr_block`: The CIDR block associated with the subnet
    - `tags`: A map of tags for the subnet
    - `availability_zone`: The availability zone where the subnet is located
    - `subnet_type`: The type of the subnet (user/created/default)
    - `vpc`: The VPC for the subnet
      - `name`: The name of the VPC
      - `id`: The id of the VPC
      - `type`: Indicates who created the VPC
        - `user`: A user created the VPC using ClickOps. If you want this the `id` should be null and **you should provide the subnet name**
        - `created`: We make the VPC using Terraform. If you want this the `name` should be `null` and **you should provide the subnet id**
        - `default`: The default VPC that AWS created. If you want this both `name` and `id` should be `null`
  - `user_eks_clusters`: A list of user-created EKS clusters that you would like to update permissions for and add monitoring to
    - cluster name: The name of the cluster
    - user_names: The list of the user names
  - `vpc`: A list of custom VPCs and their CIDR blocks
    - `name`: The name of the custom VPC
    - `cidr_block`: The CIDR block for the custom VPC
  - `width`: The width of each widgets
- Outputs
  - `aws_region`: The AWS region to provision to
  - `eks_clusters`: Outputs a map of EKS clusters and the users to be given admin access to them
  - `list_of_alarm_arns`: A list of all alarms provisioned for the service. Used to create an overview dashboard
  - mode: Validates that the same template is always run (dash_and_infra or dash_only)
  - `public_ip`: Outputs the public IP address of the web server so it can be http-checked in our tests
- 

`dash_only`: Provisions an alarm dashboard by searching for existing infrastructure with a given Service tag. Useful for adding continuous monitoring to existing resources/services (created **outside** of terraform or managed by a **different** terraform state).
- Inputs
  - `service_name`: The name of the common service you're provisioning for
  - `aws_region`: The AWS region to provision to
  - `height`: The height of each widgets
  - `list_of_emails`: A list of emails that you would like to receive updates for the dashboard alarms
    - **Must include only SAIC emails**
  - `num_widgets`: The number of widgets in a dashboard row
  - `width`: The width of each widgets
- Outputs
  - `list_of_alarm_arns`: A list of all alarms provisioned for the service. Used to create an overview dashboard
  - `mode`: Validates that the same template is always run (`dash_and_infra` or `dash_only`)

# Usage
**Letâ€™s walk through how to make an example service that uses each of our modules with a `dash_and_infra` implementation or a `dash_only` (and `infra_only` for testing purposes) implementation. Both of these examples can be found in the `examples` directory of the repo:**

**Note on shell scripts (`kube_config.sh` and `aws.sh`):**
Unfortunately, Terraform does not have support for all AWS API calls. If/when you encounter services (like EKS (kube_config.sh) or listing all available for certain services (aws.sh), there is usually an AWS CLI or kubectl command that will perform the same functionality. **Try to do as much as possible through terraform**, but know that you can do things through shell scripts if you need to.

`aws.sh` should be run **before** provisioning dash_only services. kube_config.sh should be run after provisioning dash_and_infra or infra_only services that require Kubernetes permissions/monitoring configuration.

:information_source: kube_config.sh does install the CloudWatch agent on your Kubernetes cluster

Simultaneous (`dash_and_infra` template, 2 EC2 instances, 3 server EC2 instances (2 used in containers), 2 lambda functions, 1 VPC, 4 subnets, 4 route tables, 2 NAT gateways, 1 security group, 1 ECS-EC2 task, 1 ECS-Fargate task, 1 ECS cluster, 1 EKS cluster, 1 EKS-Fargate profile, 1 EKS-EC2 node group, and 1 Elastic Beanstalk app (with 1 environment))
1. Letâ€™s start by making a folder inside of the examples directory for our service and switch to it
   ```
   $ mkdir examples/simultaneous && cd $_
   --------------------
   c1_saic_internprog/
   â”œâ”€â”€ examples
   â”‚Â Â  â”œâ”€â”€ simultaneous
   ```
2. Next, make the .tfvars file for this example
   ```
   $ echo > dash.tfvars
   --------------------
   c1_saic_internprog/
   â”œâ”€â”€ examples
   â”‚Â Â  â”œâ”€â”€ simultaneous
   â”‚   â”‚   â”œâ”€â”€ hello_python.zip
   â”‚   â”‚   â”œâ”€â”€ hello_python_2.zip
   â”‚   â”‚   â”œâ”€â”€ simultaneous.tfvars
   ```
   :information_source:**Note: If you are creating lambda functions, you also need to add a .zip file of the code**
3. Change the values of simultaneous variables by opening the simultaneous.tfvars file
   ```
   ```
   Each of these variables controls a different aspect of our configuration. To see which variables control what aspect of the config, please view the inputs documentation for this template
4. Create a new workspace for this service in the `examples/templates/dash_and_infra folder`
   ```
   $ terraform workspace new simultaneous
   ```
   For more about terraform workspaces, please see [Workspaces | Terraform by HashiCorp](https://www.terraform.io/language/state/workspaces)
5. Create a Taskfile for the service
   ```
   ```
   For more info on the Taskfile, go to: [Home | Task](https://taskfile.dev/)

# Modules
**This is a list of modules used by the services and their inputs/outputs**

Template for below documentation:
- `Name`: Description
  - Inputs
    - `input name`: Input description
  - Outputs
    - output name: Output description

#
- `beanstalk`: Provision an elastic beanstalk app
  - Inputs
    - `bean_app_name`: The name of the Elastic Beanstalk Application
    - `bean_env_name`: The list of the Elastic Beanstalk Environment names
    - `instance_profile_name`: Instance profile name for Elastic Beanstalk
    - `solution_stack_name`: The name of the solution stack being used
    - `subnet_ids`: The list of IDs for the subnets
  - Outputs
    - None
- `beanstalk_alarms`: Provision alarms for Elastic Beanstalk
  - Input
    - `bean_app_name`: Name of the Elastic Beanstalk Application
    - `bean_env_names`: List of the Elastic Beanstalk Environment names
    - `sns_arn:` ARN of the appropriate SNS topic based on service
  - Output
    - `bean_app_name`: The name of the Elastic Beanstalk Application
    - `list_of_alarm_arns`: A list of all alarms provisioned for the service. Used to create an overview dashboard
- `beanstalk_data`: Gather a map of all Elastic Beanstalk applications
  - Input
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `bean_app_map`: The local map of the Elastic Beanstalk Applications
- `beanstalk_iam`: IAM role for Elastic Beanstalk
  - Input
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `instance_profile_name`: The name of the instance profile for Beanstalk EC2 instances
    - `role_arn`: The ARN of the role associated with the Beanstalk service
- `composite_alarms`: Provision a composite alarm for a service
  - Inputs
    - `alarm_text`: A formatted list containing all of the alarm names associated with a service. Automatically provisioned based on the list_of_alarm_arns output in the serviceâ€™s remote state
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `alarm_arn`: The ARN of the generated composite alarm.
- `dashboard`: Create a CloudWatch dashboard for a service
  - Inputs
    - `json`: JSON formatting template file that defines what the dashboard will look like. Automatically generated by the json_formatting module
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - None
- `ec2`: Provision EC2 instances
  - Inputs
    - `service_name`: The workspace you should be provisioning into (same as service_name)
    - `subnet_id`: ID of the VPC subnet to provision in
    - `tags`: All applicable tags for an EC2 instance
  - Outputs
    - `instance_id`: The instance ID of the EC2 instance
    - `instance_name`: The name of the EC2 instance
- `ec2_alarms`: Provision alarms for EC2 instances
  - Inputs
    - `ec2_instance_id`: The instance ID of the target EC2 instance
    - `ec2_instance_name`: The instance name of the target EC2 instance
    - sns_arn: ARN of the appropriate SNS topic based on service
  - Outputs
    - `ec2_instance_name`: The instance name of the target EC2 instance
    - `list_of_alarm_arns`: A list of all alarms provisioned for the service. Used to create an overview dashboard
- `ec2_data`: Gather the names and ids of the EC2 instances
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `ids_list`: A list of EC2 instance IDs for that service
    - `names_list`: A list of EC2 instance names for that service
- `ecs`: Provisions an ECS task with the EC2 launch type
  - Inputs
    - `availability_zone`: The specific AWS availability zone to provision the ECS Task
    - `cluster_name`: The name of the cluster to which this ECS task description is being assigned
    - `container_definitions`: An object containing definitions for each of the containers involved in a task
      - `name`: The name of a container
      - `image`: The image used to start a container
      - `essential`: Option to decide if the task stops upon container failure
      - `port_mappings`: Allows containers to access ports on the host container instance to send or receive traffic
        - `containerPort`: The port number on the container that's bound to the user-specified or automatically assigned host port
        - `hostPort`: The port number on the container instance to reserve for your container
    - `services`: The name of the ECS services to provision for a given task definition
      - `name`: The name of ECS service
      - `desired_count`: The number services you need for ECS
    - `task_name`: The name of the ECS task being generated
  - Outputs
    - None
- `ecs_alarms`: Provision alarms for ECS instances
  - Inputs
    - `cluster_name`: Cluster name of target ECS Cluster
    - `sns_arn`: ARN of the appropriate SNS topic based on service
  - Outputs
    - `cluster_name`: The name of the ECS cluster
    - `list_of_alarm_arns`: A list of all alarms provisioned for the service. Used to create an overview dashboard
- `ecs_cluster`: Provisions an ECS cluster for a given service
    - Inputs
      - `cluster_name`: The name of the cluster to which this ECS task description is being assigned
    - Outputs
      - `cluster_arn`: The ARN of the ECS cluster
- `ecs_data`: Read data about all active ECS clusters with a given service pet name
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `ecs_names_list`: A list of the names of all active ECS clusters with a given service pet name
- `ecs_iam`: IAM for ECS clusters
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `instance_profile_name`: The name of the instance profile for ECS-EC2 instances
    - `role_arn`: The ARN of the role associated with ECS
- `eks_alarms`: Provision alarms for EKS instances
  - Input
    - `cluster_name`: The name of the EKS cluster
    - `sns_arn`: ARN of the appropriate SNS topic based on service
  - Output
    - `cluster_name`: The name of the EKS cluster
    - `list_of_alarm_arns`: A list of all alarms provisioned for this module. Used to create a service overview dashboard
- `eks_cluster`: Provisions an EKS cluster for a given service
  - Input:
    - `cluster_name`: The name of the EKS cluster
    - `role_arn`: The ARN of the role provisioned for EKS clusters
    - `subnet_ids`: A list of subnet IDs to provision to
    - `user_names`: The name of the common service you're provisioning for
  - Output:
    - `cluster_name`: The cluster name of the target EKS name
    - `endpoint`: The endpoint for the EKS cluster
    - `kubeconfig-certificate-authority-data`: The Kubernetes certificate of authority for data
    - `user_names`: The list of user ARNs that need access to the EKS cluster
- `eks_cluster_iam`: Creates an EKS cluster IAM role for a given service
  - Input:
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `role_arn`: The ARN of the role associated with EKS Cluster IAM
- `eks_data`: Gets a list of EKS clusters for a given service
  - Input:
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `names_list`: A list of EKS Clusters for that service
- `eks_fargate_profile`: Creates and assigns a Fargate profile for a given cluster
  - Input
    - `cluster_name`: The name of the EKS cluster
    - `fargate_profile_name`: The name of the Fargate profile
    - `namespace`: The namespace of the Fargate profile
    - `role_arn`: The ARN of the pod execution
    - `subnet_ids`: The list of IDs for the subnets
  - Output
    - None
- `eks_fargate_profile_iam`: Creates a Fargate profile IAM role for a given service
  - Input
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `role_arn`: The ARN of the role associated with EKS Fargate Profile IAM
- `eks_node_group`: Provisions a new EKS node group
  - Input
    - `cluster_name`: The name of the cluster to which this EKS Node Group task description is being assigned
    - `desired_size`: Desired number of worker nodes
    - `instance_types`: A list of the EC2 instance types associated with the node group
    - `max_size`: Maximum number of worker nodes
    - `max_unavailable`: Desired max number of unavailable worker nodes during a node group update
    - `min_size`: Minimum number of worker nodes
    - `node_group_name`: The name of the node group
    - `node_role_arn`: The ARN of the IAM role for the node group
    - `subnet_ids`: The list of IDs for the subnets
  - Output:
    - None
- `eks_node_group_iam`: Creates an EKS node group IAM role for a given service
  - Input
    - `service_name`: The name of the common service you're provisioning for
  - Output
    - `role_arn`: The ARN of the role associated with EKS Node Group IAM
- `eks_user_data`: Gets a list of IAM users from a list of given usernames
  - Input
    - `cluster_name`: The name of the cluster to which this EKS User Data task description is being assigned
    - `user_names`: The list of usernames of group members
  - Output
    - `cluster_name`: The name of the target EKS cluster
    - `user_names`: The list of user ARNs that need access to the EKS cluster
- `fargate`: Provisions an ECS task with the Fargate launch type
  - Input
    - `cluster_arn`: The ARN of the cluster to which this ECS task description is being assigned
    - `container_definitions`: An object containing definitions for each of the containers involved in a task
      - `name`: The name of a container
      - `image`: The image used to start a container
      - `essential`: Option to decide if the task stops upon container failure
      - `port_mappings`: Allows containers to access ports on the host container instance to send or receive traffic
        - `containerPort`: The port number on the container that's bound to the user-specified or automatically assigned host port
        - `hostPort`: The port number on the container instance to reserve for your container
    - `cpu`: The amount of vCPU to reserve
    - `memory`: The amount of memory to reserve
    - `services`: The name of the Fargate services to provision for a given task definition
      - `name`: The name of Fargate service
      - `desired_count`: The number services you need for Fargate
    - `subnets`: A list of subnet IDs to provision to
    - `task_name`:  The name of the Fargate task being generated
  - Output
    - None
- `internet_gateway`: Provision an internet gateway for a VPC
  - Inputs
    - `internet_gateway_name`: The name of the internet gateway
    - `vpc_id`: The VPC ID for the Internet Gateway
  - Outputs
    - `internet_gateway_id`: The ID of the internet gateway
    - `internet_gateway_name`: The name of the internet gateway
- `json_formatting`: Format the JSON file for the target dashboard
  - Inputs
    - `height`: The height of a widget on the dashboard
    - `list_of_widgets`: A list of objects representing each widget that is going in the dashboard. Automatically generated using the output from the *_alarms modules
      - `name`: The name of widget
      - `alarms`: The list of alarms for the widget
    - `num_widgets`: The maximum number of widgets in a row of the dashboard
    - `width`: The width of a widget on the dashboard
  - Outputs
    - `widget_json`: A formatted JSON string containing the dashboard body of the target dashboard
- `lambda`: Provision Lambda functions
  - Inputs
    - `filename`: The path to the .zip file that contains your Lambda function code
    - `role_arn`: The role ARN for Lambda IAM
    - `security_group_ids`: List of security group IDs associated with the Lambda function
    - `service_name`: The name of the common service you're provisioning for
    - `subnet_ids`: The list of IDs for the subnets
    - `tags`: All applicable tags for the Lambda function
  - Outputs
    - `function_name`: The name of the Lambda function
- `lambda_alarms`: Provision alarms for Lambda function
  - Inputs
    - `function_name`: Name of target Lambda function
    - `sns_arn`: ARN of the appropriate SNS topic based on service
  - Outputs
    - `function_name`: The function name of the target Lambda function
    - `list_of_alarm_arns`: A list of all alarms provisioned for this module. Used to create a service overview dashboard
- `lambda_data`: Gather a list of Lambda functions associated with a service
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `function_list` : A list of Lambda functions associated with that service
- `lambda_iam`: Provision service-specific roles for a Lambda function
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `role_arn`: The ARN of the role being provisioned
- `nacl`: Provision Network ACL for a VPC
  - Inputs
    - `cidr_block`: CIDR block associated with the VPC
    - `network_acl_name`: The name of the Network ACL being provisioned
    - `rules`: An object containing a list of rules associated with the Network ACL
      - `from_port`: The port that data is coming from
      - `to_port`: The port that the data going to
      - `protocol`: The type of connection protocol (TCP/UDP/-1)
      - `rule_action`: Whether to â€œallow" or â€œdeny" the traffic
      - `rule_number`: Determines the order in which rules are executed
      - `egress`: Whether or not the rule applies to outgoing traffic
    - `subnet_ids`: The list of IDs for the subnets
  - Outputs
    - `network_acl_id`: The ID of the Network ACL being provisioned
- `nat_gateway`: Provision a NAT gateway to connect private subnets to the Internet or privately to other VPCs
  - Inputs
    - `connectivity_type`: Whether the NAT gateway is public (connects to Internet) or private (connects to other VPCs)
    - `gateway_name`: The name of the NAT gateway
    - `subnet_id`: ID of the VPC subnet to provision in
  - Outputs
    - `nat_gateway_id`: The ID of the NAT gateway
    - `nat_gateway_name`: The name of the NAT gateway
- `route_table`: Provision route tables within a VPC
  - Inputs
    - `gateway_map`: A map of the names and IDs of all of the gateways associated with a service
    - `route_table_name`: The name of the route table being provisioned
    - `routes`: Provision routes for a route table within a VPC
      - `destination_cidr_block`: The IPv4 CIDR range specified in a route in the table
      - `gateway_name`: The name of a gateway
      - `gateway_type`: The type of gateway
    - `subnet_ids`: The IDs of the subnet to associate the route table with
  - Outputs
    - `route_table_id`: The ID of the route table being provisioned
- `security_groups`: Provision security groups for a VPC
  - Inputs
    - `cidr_blocks`: CIDR blocks associated with the VPC
    - `description`: A description of the security group being provisioned
    - `rules`: A map of the rules list to be associated with the security group
      - `from_port`: The port that data is coming from
      - `to_port`: The port that the data going to
      - `protocol`: The type of connection protocol (TCP/UDP/-1)
      - `type`: Set a way to send data through a specific port (ingress/egress)
    - `security_group_name`: The name of the security group being provisioned
    - `vpc_id`: The VPC ID for the security group
  - Outputs
    - `security_group_id`: The ID of the security group being provisioned
- `server`: Provision web server EC2 instances
  - Inputs
    - `ami`: The AMI of the servers you'd like to provision
    - `cluster_name`: The name of the cluster to which this server task description is being assigned
    - `instance_profile`: The instance profile to associate with the server (needed for container instances)
    - `private_ips`: The private IP addresses of the server's private network interface
    - `security_group`: ID of the security group that should apply to the server's network interface
    - `subnet_id`: ID of the VPC subnet to provision in
    - `tags`: All applicable tags for a web server
  - Outputs
    - `instance_id`: The instance ID of the server instance
    - `instance_name`: The name of the server instance
    - `instance_public_ip`: The public IP of the instance
- `sns`: Create a service topic in AWS SNS and subscribe everyone in list_of_emails to it
  - Inputs
    - `list_of_emails`: A list of emails that you would like to receive updates for the dashboard alarms
    - `name`: The name of the SNS topic (usually service name)
  - Outputs
    - `topic_arn`: The ARN for the SNS topic
- `subnet`: Provision subnets for a VPC
  - Inputs
    - `availability_zone`: The availability zone of the subnet
    - `cidr_block`: The CIDR Block associated with the VPC
    - `subnet_type`: The subnet type (public/private)
    - `tags`: All applicable tags for a subnet
    - `vpc_id`: The VPC ID for the subnet
  - Outputs
    - `cidr_block`: The CIDR block occupied of the subnet
    - `subnet_id`: The ID of the subnet
    - `subnet_name`: The name of the subnet
- `vpc`: Provision a VPC
  - Inputs
    - `cidr_block`: The CIDR Block associated with the VPC
    - `vpc_name`: The name of the VPC
  - Outputs
    - `cidr_block`: The CIDR Block of the VPC
    - `vpc_id`: The ID of the VPC
    - `vpc_name`: The name of the VPC
- `vpc_alarms`: Provision alarms for a VPC
  - Inputs
    - `sns_arn`: ARN of the appropriate SNS topic based on service
    - `vpc_name`: The VPC ID for the VPC alarm
  - Outputs
    - `list_of_alarm_arns`: A list of all alarms provisioned for this module. Used to create a service overview dashboard
    - `vpc_id`: The ID of the VPC
- `vpc_data`: Reads the list of active VPCs for alarm provisioning (used in dash_only)
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `list_of_vpcs`: A list of IDs corresponding to all active VPCs
- `vpc_log_group`: Get the packets, bytes, vpc-id, and flow-direction from the CloudWatch Log Groups
  - Inputs
    - `log_group_name`: The name of the CloudWatch log group associated with the flow log
    - `role_arn`: The ARN of the IAM role
    - `traffic_type`: The type of traffic capture to the log. (ACCEPT/ALL/REJECT)
    - `vpc_ids`: The VPC IDs for the flow logs
  - Output
    - `log_group_name`: The name of the CloudWatch log group associated with the flow log
- `vpc_log_group_iam`: IAM Role for VPC Log Groups
  - Inputs
    - `service_name`: The name of the common service you're provisioning for
  - Outputs
    - `role_arn`: The ARN of the role being provisioned
- `vpc_metric_filter`: Creates metric filters to turn log data into VPC metrics (for use in alarms)
  - Inputs
    - `log_group_name`: The name of the CloudWatch log group associated with the metric filter
  - Outputs
    - None
